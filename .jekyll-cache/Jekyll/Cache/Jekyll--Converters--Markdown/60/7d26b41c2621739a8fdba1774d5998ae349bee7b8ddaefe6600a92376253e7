I"¸3<p class="lead">Existem muitos m√≥dulos em python especializados numa imensa gama de tarefas!</p>

<h2 id="a-biblioteca-padr√£o-de-python">A Biblioteca Padr√£o de Python</h2>

<p>A linguagem python tem por padr√£o v√°rias fun√ß√µes, suficientes para criar programas bastante complexos. A lista abaixo fornece praticamente todas as palavras-chaves do python padr√£o (<em>Standard Python</em>):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
</code></pre></div></div>

<p>Outras palavras, como <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">print</code>, <code class="language-plaintext highlighter-rouge">input</code>, etc.,  est√£o reservadas para fun√ß√µes, tipos de dados, operadores, etc. Consulte a documenta√ß√£o sobre a <strong><a href="https://docs.python.org/3/library/" target="\_blank">Biblioteca Padr√£o de Python</a></strong> (<em>Python Standard Library</em>) para uma lista gigante e praticamente completa.</p>

<h2 id="m√≥dulos">M√≥dulos</h2>

<p>Mesmo com todos esses recursos, o python s√≥ se tornou a mais importante ferramente computacional da atualidade pela sua capacidade de extender seus poderes usando <strong>m√≥dulos,</strong> que s√£o conjuntos (ou bibliotecas) de novos tipos de dados, m√©todos, operadores e fun√ß√µes  criados com uma finalidade espec√≠fica em mente: lidar com arquivos, resolver problemas num√©ricos, intelig√™ncia artificial, etc, etc, etc.</p>

<p>A lista de m√≥dulos dispon√≠veis √© praticamente infinita, imposs√≠vel de ser listada aqui. Como o curso pretende lidar com t√©cnicas computacionais de an√°lise num√©rica de dados, vamos focar num subconjunto pequeno dos m√≥dulos python para essa finalidade. Anida assim, mesmo sem conseguir trabalhar aqui com mais do que um pequeno punhado de m√≥dulos, come√ßaremos com comandos b√°sicos, v√°lidos para qualquer um deles. Com isso, voc√™ pode procurar nos <a href="/LOM3260/biblio/">Recursos</a> outros m√≥dulos que lhe interessem e test√°-los para seus objetivos. Veremos tamb√©m, mais adiante, como criar nosso pr√≥prio m√≥dulo personalizado!</p>

<p>Para fixar as ideias, vamos usar como exemplo o m√≥dulo chamado <code class="language-plaintext highlighter-rouge">numpy</code>. Voc√™ pode extrapolar os conceitos e comandos mostrados abaixo para qualquer m√≥dulo.</p>

<p class="alert alert-warning">:warning: O m√≥dulo <code class="language-plaintext highlighter-rouge">math</code> tem algumas fun√ß√µes parecidas com as encontradas no <code class="language-plaintext highlighter-rouge">numpy</code>. No entanto, o <code class="language-plaintext highlighter-rouge">math</code> n√£o √© atualmente recomend√°vel para computa√ß√£o cient√≠fica. Evite us√°-lo!</p>

<p>Usaremos como motiva√ß√£o o seguinte problema: digamos que voc√™ precise calcular a raiz quadrada de um n√∫mero. O python padr√£o n√£o tem uma fun√ß√£o para isso, mas pode ser adicionada se voc√™ incluir no seu c√≥digo algum m√≥dulo que contenha essa fun√ß√£o. O m√≥dulo <code class="language-plaintext highlighter-rouge">numpy</code> √© o mais indicado: ele cont√©m muitas fun√ß√µes matem√°ticas, como seno, cosseno, exponential, raiz quadrada, etc.</p>

<p class="alert alert-primary">:bulb: Um dos exerc√≠cios da Lista 1 (<a href="/LOM3260/material/exercicios/lista1.html#ex20">esse aqui</a>) ilustra uma poss√≠vel maneira de calcular a raiz quadrada sem usar um m√≥dulo externo, usando uma estrat√©gia num√©rica conhecida por <em>M√©todo de Newton-Raphson</em>. Voc√™ poderia us√°-la em seus pr√≥prios m√≥dulos personalizados‚Ä¶</p>

<h2 id="importanto-m√≥dulos">Importanto m√≥dulos</h2>

<p>Vejamos, ent√£o, como incluir um m√≥dulo externo no c√≥digo. Isse √© feito com o comando <code class="language-plaintext highlighter-rouge">import</code>. De forma direta, basta incluir a seguinte linha no come√ßo do seu programa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span>
</code></pre></div></div>
<p>Com isso, importamos <strong>todas</strong> as fun√ß√µes e m√©todos disponibilizados pelo m√≥dulo numpy. Por exemplo, a fun√ß√£o raiz quadrada √© chamada de <code class="language-plaintext highlighter-rouge">sqrt</code> (do ingl√™s <em>square root</em>). Usando <code class="language-plaintext highlighter-rouge">import numpy</code>, a fun√ß√£o ficar√° acess√≠vel ao seu programa como <code class="language-plaintext highlighter-rouge">numpy.sqrt</code>. Voc√™ ent√£o a chamaria assim:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">numpy</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">A raiz quadrada de </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s"> √© </span><span class="si">{</span><span class="n">rqa</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p>Essa, no entanto, √© apenas uma das maneiras de usar o comando <code class="language-plaintext highlighter-rouge">import</code>. Uma outra maneira √© dar um ‚Äúapelido‚Äù ao m√≥dulo com a palavra chave <code class="language-plaintext highlighter-rouge">as</code> (<em>como</em>):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div>
<p>onde <code class="language-plaintext highlighter-rouge">np</code> √© o apelido escolhido (√© da escolha do programador). Nesse caso, acessamos a fun√ß√£o <code class="language-plaintext highlighter-rouge">sqrt</code> precedida pelo apelido, <code class="language-plaintext highlighter-rouge">np.sqrt</code>, e n√£o mais pelo nome (<code class="language-plaintext highlighter-rouge">numpy.sqrt</code>). Veja a diferen√ßa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">A raiz quadrada de </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s"> √© </span><span class="si">{</span><span class="n">rqa</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p>Uma terceira maneira de usar o import √© a seguinte, usando o m√©todo <code class="language-plaintext highlighter-rouge">from</code> (<em>de</em>):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">A raiz quadrada de </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s"> √© </span><span class="si">{</span><span class="n">rqa</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>
<p>A linha <code class="language-plaintext highlighter-rouge">from numpy import *</code> diz, literalmente (em ingl√™s), <em>de numpy importe tudo</em>. O caractere <code class="language-plaintext highlighter-rouge">*</code> (asterisco) √© chamado de <strong>caractere-coringa</strong> (<em>wildcard</em>, em ingl√™s) pois, em analogia a jogos de cartas, ele tem o valor que voc√™ quiser, ou tudo ao mesmo tempo. Repare que, usando essa maneira de importar, as fun√ß√µes s√£o usadas sem nenhuma qualifica√ß√£o de origem, ou seja, usamos diretamente <code class="language-plaintext highlighter-rouge">sqrt(a)</code>, e n√£o <code class="language-plaintext highlighter-rouge">numpy.sqrt(a)</code> ou <code class="language-plaintext highlighter-rouge">np.sqrt(a)</code>. Com a constru√ß√£o <code class="language-plaintext highlighter-rouge">from import</code>, voc√™ poderia tamb√©m importar apenas a fun√ß√£o que lhe interessa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">A raiz quadrada de </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s"> √© </span><span class="si">{</span><span class="n">rqa</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>
<p>Isso tem um certo ganho de efici√™ncia, pois menos fun√ß√µes, m√©todos e vari√°veis s√£o criadas pelo seu programa, usando assim menos mem√≥ria. Mas essa vantagem √© contrabalanceada pelo seguinte problema:</p>

<p class="alert alert-danger">:x: Fuja do uso da constru√ß√£o <code class="language-plaintext highlighter-rouge">from modulo import *</code> ou <code class="language-plaintext highlighter-rouge">from modulo import metodo</code>. Isso n√£o √© recomendado, pois seu programa poderia ter fun√ß√µes ou vari√°veis com o mesmo nome de fun√ß√µes ou vari√°veis do <code class="language-plaintext highlighter-rouge">modulo</code> importado. Esses <em>conflitos</em> levariam a erros de execu√ß√£o.</p>

<p>Para evitar isso, voc√™ pode combinar a constru√ß√£o <code class="language-plaintext highlighter-rouge">from</code> com <code class="language-plaintext highlighter-rouge">as</code>, importando apenas a fun√ß√£o <code class="language-plaintext highlighter-rouge">sqrt</code> do <code class="language-plaintext highlighter-rouge">numpy</code>, mas dando-lhe um apelido:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span> <span class="k">as</span> <span class="n">raiz</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="nf">raiz</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">A raiz quadrada de </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s"> √© </span><span class="si">{</span><span class="n">rqa</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p>√â pouco prov√°vel que exista uma fun√ß√£o <code class="language-plaintext highlighter-rouge">raiz</code> no numpy, ent√£o o problema √© contornado ‚Äî mas sem nenhuma garantia: e se um dos desenvolvedores do <code class="language-plaintext highlighter-rouge">numpy</code> √© lus√≥fono e usou a palavra <code class="language-plaintext highlighter-rouge">raiz</code> internamente no c√≥digo? Por isso, eu n√£o recomendo usar a constru√ß√£o <code class="language-plaintext highlighter-rouge">from</code>, nem mesmo com o uso concomitante do <code class="language-plaintext highlighter-rouge">as</code>. √â melhor, por seguran√ßa e compatibilidade, importar os m√≥dulos completos, com <code class="language-plaintext highlighter-rouge">import numpy</code> ou <code class="language-plaintext highlighter-rouge">import numpy as np</code>.</p>
:ET