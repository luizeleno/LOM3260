I"…,<p class="lead">Existem muitos m√≥dulos em python especializados numa imensa gama de tarefas!</p>

<h2 id="a-biblioteca-padr√£o-de-python">A Biblioteca Padr√£o de Python</h2>

<p>A linguagem python tem por padr√£o v√°rias fun√ß√µes, suficientes para criar programas bastante complexos. A lista abaixo fornece praticamente todas as palavras-chaves do python padr√£o (<em>Standard Python</em>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
</code></pre></div></div>

<p>Outras palavras, como <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">print</code>, <code class="highlighter-rouge">input</code>, etc.,  est√£o reservadas para fun√ß√µes, tipos de dados, operadores, etc. Consulte a documenta√ß√£o sobre a <strong><a href="https://docs.python.org/3/library/" target="\_blank">Biblioteca Padr√£o de Python</a></strong> (<em>Python Standard Library</em>) para uma lista gigante e praticamente completa.</p>

<h2 id="m√≥dulos">M√≥dulos</h2>

<p>Mesmo com todos esses recursos, o python s√≥ se tornou a mais importante ferramente computacional da atualidade pela sua capacidade de extender seus poderes usando <strong>m√≥dulos,</strong> que s√£o conjuntos (ou bibliotecas) de novos tipos de dados, m√©todos, operadores e fun√ß√µes  criados com uma finalidade espec√≠fica em mente: lidar com arquivos, resolver problemas num√©ricos, intelig√™ncia artificial, etc, etc, etc.</p>

<p>A lista de m√≥dulos dispon√≠veis √© praticamente infinita, imposs√≠vel de ser listada aqui. Como o curso pretende lidar com t√©cnicas computacionais de an√°lise num√©rica de dados, vamos focar num subconjunto pequeno dos m√≥dulos python para essa finalidade. Anida assim, mesmo sem conseguir trabalhar aqui com mais do que um pequeno punhado de m√≥dulos, come√ßaremos com comandos b√°sicos, v√°lidos para qualquer um deles. Com isso, voc√™ pode procurar nos <a href="/LOM3260/biblio/">Recursos</a> outros m√≥dulos que lhe interessem e test√°-los para seus objetivos. Veremos tamb√©m, mais adiante, como criar nosso pr√≥prio m√≥dulo personalizado!</p>

<p>Para fixar as ideias, vamos usar como exemplo o m√≥dulo chamado <code class="highlighter-rouge">numpy</code>. Voc√™ pode extrapolar os conceitos e comandos mostrados abaixo para qualquer m√≥dulo.</p>

<p class="alert alert-warning">:warning: O m√≥dulo <code class="highlighter-rouge">math</code> tem algumas fun√ß√µes parecidas com as encontradas no <code class="highlighter-rouge">numpy</code>. No entanto, o <code class="highlighter-rouge">math</code> n√£o √© atualmente recomend√°vel para computa√ß√£o cient√≠fica. Evite us√°-lo!</p>

<p>Usaremos como motiva√ß√£o o seguinte problema: digamos que voc√™ precise calcular a raiz quadrada de um n√∫mero. O python padr√£o n√£o tem uma fun√ß√£o para isso, mas pode ser adicionada se voc√™ incluir no seu c√≥digo algum m√≥dulo que contenha essa fun√ß√£o. O m√≥dulo <code class="highlighter-rouge">numpy</code> √© o mais indicado: ele cont√©m muitas fun√ß√µes matem√°ticas, como seno, cosseno, exponential, raiz quadrada, etc.</p>

<p class="alert alert-primary">:bulb: Um dos exerc√≠cios da Lista 1 (<a href="/LOM3260/docs/exercicios/lista1.html#exerc%C3%ADcio-20">esse aqui</a>) ilustra uma poss√≠vel maneira de calcular a raiz quadrada sem usar um m√≥dulo externo, usando uma estrat√©gia num√©rica conhecida por <em>M√©todo de Newton-Raphson</em>. Voc√™ poderia us√°-la em seus pr√≥prios m√≥dulos personalizados‚Ä¶</p>

<h2 id="importanto-m√≥dulos">Importanto m√≥dulos</h2>

<p>Vejamos, ent√£o, como incluir um m√≥dulo externo no c√≥digo. Isse √© feito com o comando <code class="highlighter-rouge">import</code>. De forma direta, basta incluir a seguinte linha no come√ßo do seu programa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span>
</code></pre></div></div>
<p>Com isso, importamos <strong>todas</strong> as fun√ß√µes e m√©todos disponibilizados pelo m√≥dulo numpy. Por exemplo, a fun√ß√£o raiz quadrada √© chamada de <code class="highlighter-rouge">sqrt</code> (do ingl√™s <em>square root</em>). Usando <code class="highlighter-rouge">import numpy</code>, a fun√ß√£o ficar√° acess√≠vel ao seu programa como <code class="highlighter-rouge">numpy.sqrt</code>. Voc√™ ent√£o a chamaria assim:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A raiz quadrada de {a} √© {rqa}'</span><span class="p">)</span>
</code></pre></div></div>

<p>Essa, no entanto, √© apenas uma das maneiras de usar o comando <code class="highlighter-rouge">import</code>. Uma outra maneira √© dar um ‚Äúapelido‚Äù ao m√≥dulo com a palavra chave <code class="highlighter-rouge">as</code> (<em>como</em>):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
</code></pre></div></div>
<p>onde <code class="highlighter-rouge">np</code> √© o apelido escolhido (√© da escolha do programador). Nesse caso, acessamos a fun√ß√£o <code class="highlighter-rouge">sqrt</code> precedida pelo apelido, <code class="highlighter-rouge">np.sqrt</code>, e n√£o mais pelo nome (<code class="highlighter-rouge">numpy.sqrt</code>). Veja a diferen√ßa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A raiz quadrada de {a} √© {rqa}'</span><span class="p">)</span>
</code></pre></div></div>

<p>Uma terceira maneira de usar o import √© a seguinte, usando o m√©todo <code class="highlighter-rouge">from</code> (<em>de</em>):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A raiz quadrada de {a} √© {rqa}'</span><span class="p">)</span>
</code></pre></div></div>
<p>A linha <code class="highlighter-rouge">from numpy import *</code> diz, literalmente (em ingl√™s), <em>de numpy importe tudo</em>. O caractere <code class="highlighter-rouge">*</code> (asterisco) √© chamado de <strong>caractere-coringa</strong> (<em>wildcard</em>, em ingl√™s) pois, em analogia a jogos de cartas, ele tem o valor que voc√™ quiser, ou tudo ao mesmo tempo. Repare que, usando essa maneira de importar, as fun√ß√µes s√£o usadas sem nenhuma qualifica√ß√£o de origem, ou seja, usamos diretamente <code class="highlighter-rouge">sqrt(a)</code>, e n√£o <code class="highlighter-rouge">numpy.sqrt(a)</code> ou <code class="highlighter-rouge">np.sqrt(a)</code>. Com a constru√ß√£o <code class="highlighter-rouge">from import</code>, voc√™ poderia tamb√©m importar apenas a fun√ß√£o que lhe interessa:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A raiz quadrada de {a} √© {rqa}'</span><span class="p">)</span>
</code></pre></div></div>
<p>Isso tem um certo ganho de efici√™ncia, pois menos fun√ß√µes, m√©todos e vari√°veis s√£o criadas pelo seu programa, usando assim menos mem√≥ria. Mas essa vantagem √© contrabalanceada pelo seguinte problema:</p>

<p class="alert alert-danger">:x: Fuja do uso da constru√ß√£o <code class="highlighter-rouge">from modulo import *</code> ou <code class="highlighter-rouge">from modulo import metodo</code>. Isso n√£o √© recomendado, pois seu programa poderia ter fun√ß√µes ou vari√°veis com o mesmo nome de fun√ß√µes ou vari√°veis do <code class="highlighter-rouge">modulo</code> importado. Esses <em>conflitos</em> levariam a erros de execu√ß√£o.</p>

<p>Para evitar isso, voc√™ pode combinar a constru√ß√£o <code class="highlighter-rouge">from</code> com <code class="highlighter-rouge">as</code>, importando apenas a fun√ß√£o <code class="highlighter-rouge">sqrt</code> do <code class="highlighter-rouge">numpy</code>, mas dando-lhe um apelido:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sqrt</span> <span class="k">as</span> <span class="n">raiz</span>

<span class="n">a</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">rqa</span> <span class="o">=</span> <span class="n">raiz</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">'A raiz quadrada de {a} √© {rqa}'</span><span class="p">)</span>
</code></pre></div></div>

<p>√â pouco prov√°vel que exista uma fun√ß√£o <code class="highlighter-rouge">raiz</code> no numpy, ent√£o o problema √© contornado ‚Äî mas sem nenhuma garantia: e se um dos desenvolvedores do <code class="highlighter-rouge">numpy</code> √© lus√≥fono e usou a palavra <code class="highlighter-rouge">raiz</code> internamente no c√≥digo? Por isso, eu n√£o recomendo usar a constru√ß√£o <code class="highlighter-rouge">from</code>, nem mesmo com o uso concomitante do <code class="highlighter-rouge">as</code>. √â melhor, por seguran√ßa e compatibilidade, importar os m√≥dulos completos, com <code class="highlighter-rouge">import numpy</code> ou <code class="highlighter-rouge">import numpy as np</code>.</p>
:ET